new basket,
  articles,
  update,
  create,
  entry,
  entryUriCh,
  updateUriCh,
  publicKeyCh,
  nonceCh,
  hashCh,
  verifySignatureCh,
  dapp,
  insertArbitrary(`rho:registry:insertArbitrary`),
  stdout(`rho:io:stdout`),
  secpVerify(`rho:crypto:secp256k1Verify`),
  blake2b256(`rho:crypto:blake2b256Hash`)
in {
  publicKeyCh!!("PUBLIC_KEY") |
  nonceCh!("NONCE") |

  dapp!("DAPPY_FILE") |

  // Send an initially empty map
  articles!({}) |

  // create a record
  contract create(payload, return) = {
    stdout!("create") |
    for (current <- articles) {
      match *current.contains(*payload.get("article").get("id")) {
        true => {
          return!("error: id " ++ *payload.get("article").get("id") ++ " already taken") |
          articles!(*current)
        }
        false => {
          for (@nonce <- nonceCh; @publicKey <- publicKeyCh) {
            blake2b256!(
              nonce.toUtf8Bytes(),
              *hashCh
            ) |
            stdout!(publicKey) |
            stdout!(nonce) |
            stdout!(*payload.get("signature")) |
            for (@hash <- hashCh) {
              stdout!(hash) |
              secpVerify!(
                hash,
                *payload.get("signature").hexToBytes(),
                publicKey.hexToBytes(),
                *verifySignatureCh
              ) |
              for (@result <- verifySignatureCh) {
                match result {
                  true => {
                    return!("success: article " ++ *payload.get("article").get("id") ++ " created") |
                    articles!(*current.set(*payload.get("article").get("id"), *payload.get("article"))) |
                    nonceCh!(*payload.get("nonce"))
                  }
                  false => {
                    return!("error: signature invalid") |
                    articles!(*current) |
                    nonceCh!(nonce)
                  }
                }
              }
            }
          }
        }
      }
    }
  } |

  contract entry(action, return) = {
    match *action.get("type") {
      "CREATE" => {
        create!(*action.get("payload"), *return)
      }
    }
  } |

  insertArbitrary!(*entry, *entryUriCh) |

  for (uri <- entryUriCh) {
    basket!({
      "registry_uri": *uri,
      "unforgeable_name": *dapp,
      "unforgeable_name_articles": *articles,
      "unforgeable_name_nonce": *nonceCh,
      "public_key": "PUBLIC_KEY"
    }) |
    stdout!({
      "registry_uri": *uri,
      "unforgeable_name": *dapp,
      "unforgeable_name_articles": *articles,
      "unforgeable_name_nonce": *nonceCh,
      "public_key": "PUBLIC_KEY"
    })
  }
}
